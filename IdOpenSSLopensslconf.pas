unit IdOpenSSLopensslconf;
{$I IdCompilerDefines.inc}

interface

uses
  IdException,
  IdCTypes;

{
  Automatically converted by H2Pas 1.0.0 from openssl-1.1.0l/include/openssl/opensslconf.h
  The following command line parameters were used:
  -p
  -P
  -t
  -T
  -C
  openssl-1.1.0l/include/openssl/opensslconf.h
}

{$IFDEF FPC}
{$PACKRECORDS C}
{$ENDIF}
{
  * WARNING: do not edit!
  * Generated by Makefile from include/openssl/opensslconf.h.in
  *
  * Copyright 2016-2018 The OpenSSL Project Authors. All Rights Reserved.
  *
  * Licensed under the OpenSSL license (the "License").  You may not use
  * this file except in compliance with the License.  You can obtain a copy
  * in the file LICENSE in the source distribution or at
  * https://www.openssl.org/source/license.html
}
{ C++ extern C conditionnal removed }
{$IFDEF OPENSSL_ALGORITHM_DEFINES}
{$ERROR OPENSSL_ALGORITHM_DEFINES no longer supported}
{$ENDIF}
{
  * OpenSSL was configured with the following options:
}
{$IFNDEF OPENSSL_SYS_MINGW32}
{$IFDEF WIN64}

const
  OPENSSL_SYS_MINGW64 = 1;
{$ELSE}

const
  OPENSSL_SYS_MINGW32 = 1;
{$ENDIF}
{$ENDIF}
{$IFNDEF OPENSSL_NO_MD2}
{$DEFINE OPENSSL_NO_MD2}
{$ENDIF}
{$IFNDEF OPENSSL_NO_RC5}
{$DEFINE OPENSSL_NO_RC5}
{$ENDIF}
{$IFNDEF OPENSSL_THREADS}
{$DEFINE OPENSSL_THREADS}
{$ENDIF}
{$IFNDEF OPENSSL_NO_ASAN}
{$DEFINE OPENSSL_NO_ASAN}
{$ENDIF}
{$IFNDEF OPENSSL_NO_CRYPTO_MDEBUG}
{$DEFINE OPENSSL_NO_CRYPTO_MDEBUG}
{$ENDIF}
{$IFNDEF OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE}
{$DEFINE OPENSSL_NO_CRYPTO_MDEBUG_BACKTRACE}
{$ENDIF}
{$IFNDEF OPENSSL_NO_EC_NISTP_64_GCC_128}
{$DEFINE OPENSSL_NO_EC_NISTP_64_GCC_128}
{$ENDIF}
{$IFNDEF OPENSSL_NO_EGD}
{$DEFINE OPENSSL_NO_EGD}
{$ENDIF}
{$IFNDEF OPENSSL_NO_FUZZ_AFL}
{$DEFINE OPENSSL_NO_FUZZ_AFL}
{$ENDIF}
{$IFNDEF OPENSSL_NO_FUZZ_LIBFUZZER}
{$DEFINE OPENSSL_NO_FUZZ_LIBFUZZER}
{$ENDIF}
{$IFNDEF OPENSSL_NO_HEARTBEATS}
{$DEFINE OPENSSL_NO_HEARTBEATS}
{$ENDIF}
{$IFNDEF OPENSSL_NO_MSAN}
{$DEFINE OPENSSL_NO_MSAN}
{$ENDIF}
{$IFNDEF OPENSSL_NO_SCTP}
{$DEFINE OPENSSL_NO_SCTP}
{$ENDIF}
{$IFNDEF OPENSSL_NO_SSL_TRACE}
{$DEFINE OPENSSL_NO_SSL_TRACE}
{$ENDIF}
{$IFNDEF OPENSSL_NO_SSL3}
{$DEFINE OPENSSL_NO_SSL3}
{$ENDIF}
{$IFNDEF OPENSSL_NO_SSL3_METHOD}
{$DEFINE OPENSSL_NO_SSL3_METHOD}
{$ENDIF}
{$IFNDEF OPENSSL_NO_UBSAN}
{$DEFINE OPENSSL_NO_UBSAN}
{$ENDIF}
{$IFNDEF OPENSSL_NO_UNIT_TEST}
{$DEFINE OPENSSL_NO_UNIT_TEST}
{$ENDIF}
{$IFNDEF OPENSSL_NO_WEAK_SSL_CIPHERS}
{$DEFINE OPENSSL_NO_WEAK_SSL_CIPHERS}
{$ENDIF}
{$IFNDEF OPENSSL_NO_AFALGENG}
{$DEFINE OPENSSL_NO_AFALGENG}
{$ENDIF}
  {
    * Sometimes OPENSSSL_NO_xxx ends up with an empty file and some compilers
    * don't like that.  This will hopefully silence them.
  }
  (* error
    #define NON_EMPTY_TRANSLATION_UNIT static void *dummy = &dummy;
    in declaration at line 94 *)
  {
    * Applications should use -DOPENSSL_API_COMPAT=<version> to suppress the
    * declarations of functions deprecated in or before <version>. Otherwise, they
    * still won't see them if the library has been built to disable deprecated
    * functions.
  }
{$IFNDEF OPENSSL_FILE}
{$IFDEF OPENSSL_NO_FILENAMES}

const
  OPENSSL_FILE = '';
  OPENSSL_LINE = 0;
{$ELSE}
  // const
  // OPENSSL_FILE = __FILE__;
  // OPENSSL_LINE = __LINE__;
{$ENDIF}
{$ENDIF}
{$IFNDEF OPENSSL_MIN_API}

const
  OPENSSL_MIN_API = 0;
{$ENDIF}
{$IF !defined(OPENSSL_API_COMPAT) || OPENSSL_API_COMPAT < OPENSSL_MIN_API}
{$UNDEF OPENSSL_API_COMPAT}

const
  OPENSSL_API_COMPAT = OPENSSL_MIN_API;
{$IFEND}
{$DEFINE OPENSSL_CPUID_OBJ}
  { Generate 80386 code? }
{$UNDEF I386_ONLY}
{$UNDEF OPENSSL_UNISTD}
  (* error
    #define OPENSSL_UNISTD <unistd.h>
    in define line 159 *)
{$DEFINE OPENSSL_EXPORT_VAR_AS_FUNCTION}
  {
    * The following are cipher-specific, but are part of the public API.
  }
{$IF !defined(OPENSSL_SYS_UEFI)}
{$IFNDEF WIN64}
{$DEFINE BN_LLONG}
{$ELSE}
{$UNDEF BN_LLONG}
{$ENDIF}
  { Only one for the following should be defined }
{$UNDEF SIXTY_FOUR_BIT_LONG}
{$IFNDEF WIN64}
{$UNDEF SIXTY_FOUR_BIT}
{$DEFINE THIRTY_TWO_BIT}
{$ELSE}
{$DEFINE SIXTY_FOUR_BIT}
{$UNDEF THIRTY_TWO_BIT}
{$ENDIF}
{$IFEND}

type
  RC4_INT = TIdC_INT;
  { C++ end of extern C conditionnal removed }

  EIdOpenSSLStubError = class(EIdException)
  protected
    FError: UInt32;
    FErrorMessage: String;
    FTitle: String;
  public
    constructor Build(const ATitle: String; AError: UInt32);
    property Error: UInt32 read FError;
    property ErrorMessage: String read FErrorMessage;
    property Title: String read FTitle;
  end;

  EIdOpenSSL_Crypto_Error = class(EIdOpenSSLStubError);
  EIdOpenSSL_SSL_Error = class(EIdOpenSSLStubError);

var
  GCryptHandle: THandle;
  GSSLHandle: THandle;

procedure IdOpenSSLSetLibPath(const APath: String);

function CryptoFixupStub(const AName: String): Pointer;
function SSLFixupStub(const AName: String): Pointer;

implementation

uses
  IdGlobal,
  IdOpenSSLConst,
  SysUtils;

var
  GIdOpenSSLPath: String = '';

procedure IdOpenSSLSetLibPath(const APath: String);
begin
  if APath <> '' then
  begin
    GIdOpenSSLPath := IndyIncludeTrailingPathDelimiter(APath);
  end
  else
  begin
    GIdOpenSSLPath := '';
  end;
end;

{$IFDEF WINDOWS}

const
{$IFDEF WIN64}
  SSL_DLL_1_1_name = 'libssl-1_1-x64.dll'; { Do not localize }
  SSL_DLL_3_name = 'libssl-3-x64.dll'; { Do not localize }
{$ELSE}
  SSL_DLL_1_1_name = 'libssl-1_1.dll'; { Do not localize }
  SSL_DLL_3_name = 'libssl-3.dll'; { Do not localize }
{$ENDIF}
  SSLCLIB_DLL_name = 'libeay32.dll'; { Do not localize }
{$IFDEF WIN64}
  SSLCLIB_DLL_1_1_name = 'libcrypto-1_1-x64.dll'; { Do not localize }
  SSLCLIB_DLL_3_name = 'libcrypto-3-x64.dll'; { Do not localize }
{$ELSE}
  SSLCLIB_DLL_1_1_name = 'libcrypto-1_1.dll'; { Do not localize }
  SSLCLIB_DLL_3_name = 'libcrypto-3.dll'; { Do not localize }
{$ENDIF}
  SSLCLIBS_LAST = 1;
  SSLCLIBS: array [0 .. SSLCLIBS_LAST] of string = (SSLCLIB_DLL_3_name,
    SSLCLIB_DLL_1_1_name);
  SSLLIBS_LAST = 1;
  SSLLIBS: array [0 .. SSLLIBS_LAST] of string = (SSL_DLL_3_name,
    SSL_DLL_1_1_name);
{$ENDIF}
  { EIdOpenSSLStubError }

constructor EIdOpenSSLStubError.Build(const ATitle: String; AError: UInt32);
begin
  FTitle := ATitle;
  FError := AError;
  if AError = 0 then
  begin
    inherited Create(ATitle);
  end
  else
  begin
    FErrorMessage := SysUtils.SysErrorMessage(AError);
    inherited Create(ATitle + ': ' + FErrorMessage); { Do not Localize }
  end;
end;

function LoadCrypto: THandle;
{$IFDEF WINDOWS}
var
  i: Integer;
{$ENDIF}
begin
{$IFDEF WINDOWS}
  if GCryptHandle = IdNilHandle then
  begin
    // On Windows, you should use SafeLoadLibrary because
    // the LoadLibrary API call messes with the FPU control word.
    for i := 0 to SSLCLIBS_LAST do
    begin
      Result := SafeLoadLibrary(GIdOpenSSLPath + SSLCLIBS[i]);
      if Result <> IdNilHandle then
      begin
        Exit;
      end;
    end;

  end
  else
  begin
    Result := GCryptHandle;
  end;
{$ENDIF}
end;

function LoadSSL: THandle;
{$IFDEF WINDOWS}
var
  i: Integer;
{$ENDIF}
begin
{$IFDEF WINDOWS}
  if GSSLHandle = IdNilHandle then
  begin

    // On Windows, you should use SafeLoadLibrary because
    // the LoadLibrary API call messes with the FPU control word.
    for i := 0 to SSLLIBS_LAST do
    begin
      Result := SafeLoadLibrary(GIdOpenSSLPath + SSLLIBS[i]);
      GSSLHandle := Result;
      if Result <> IdNilHandle then
      begin
        Exit;
      end;
    end;
  end
  else
  begin
    Result := GSSLHandle;
  end;
  {$ENDIF}
end;

function CryptoFixupStub(const AName: String): Pointer;
begin
  if GCryptHandle = IdNilHandle then
  begin
    if not LoadCrypto <> IdNilHandle then
    begin
      raise EIdOpenSSL_Crypto_Error.Build(Format(RSLibCryptoCallError,
        [AName]), 0);
    end;
  end;
  Result := LoadLibFunction(GCryptHandle, AName);
  if Result = nil then
  begin
    raise EIdOpenSSL_Crypto_Error.Build(Format(RSLibCryptoCallError,
      [AName]), 10022);
  end;
end;

function SSLFixupStub(const AName: TIdLibFuncName): Pointer;
begin
  if GSSLHandle = IdNilHandle then
  begin
    if not LoadSSL <> IdNilHandle then
    begin
      raise EIdOpenSSL_Crypto_Error.Build(Format(RSLibSSLCallError,
        [AName]), 0);
    end;
  end;
  Result := LoadLibFunction(GSSLHandle, AName);
  if Result = nil then
  begin
    raise EIdOpenSSL_SSL_Error.Build(Format(RSLibSSLCallError, [AName]), 10022);
  end;
end;

end.
